# Визуализация растровых алгоритмов с использованием OpenCV.js

## Описание

Интерактивное веб-приложение для изучения и сравнения классических алгоритмов компьютерной графики с интеграцией OpenCV.js. Позволяет визуализировать процесс построения графических примитивов на растровой сетке с возможностью измерения производительности и демонстрации использования компьютерного зрения в браузере.

## Возможности

### Поддерживаемые алгоритмы:

- **Пошаговый алгоритм** - базовый метод с накоплением ошибок округления
- **Алгоритм ЦДА (DDA)** - цифровой дифференциальный анализатор с дробными шагами  
- **Алгоритм Брезенхема (линия)** - целочисленный алгоритм без операций с плавающей точкой
- **Алгоритм Брезенхема (окружность)** - эффективное построение с использованием 8-сторонней симметрии
- **Алгоритм Ву** - сглаживание линий с антиалиасингом через OpenCV

### Система визуализации:

- Координатная сетка 800×800 пикселей
- Центр координат в середине холста
- Подписи осей с шагом 1 единица
- Дискретное отображение пикселей в виде квадратов
- Интеграция OpenCV.js для аппаратно-ускоренной отрисовки

## Технологии

- **Frontend**: HTML5, CSS3, JavaScript ES6+
- **Компьютерное зрение**: OpenCV.js 4.8.0
- **Графика**: Canvas API + OpenCV Mat операции
- **Производительность**: Performance API для точных замеров
- **Интерфейс**: Адаптивная верстка с CSS Grid/Flexbox

## Реализованные алгоритмы

### 1. Пошаговый алгоритм

**Принцип работы**: Самый простой алгоритм растеризации отрезка. Координаты X и Y изменяются равномерно с постоянным шагом.

**Математические формулы**:
- `steps = max(|Δx|, |Δy|)`
- `x_inc = Δx / steps`
- `y_inc = Δy / steps`

**Реализация**:
```javascript
function stepByStep(x1, y1, x2, y2) {
    const dx = x2 - x1, dy = y2 - y1;
    const steps = Math.max(Math.abs(dx), Math.abs(dy));
    const xinc = dx / steps, yinc = dy / steps;
    let x = x1, y = y1;
    for (let i = 0; i <= steps; i++) {
        plot(Math.round(x), Math.round(y));
        x += xinc; y += yinc;
    }
}
```

**Преимущества**:
- Простота реализации и понимания
- Легко отлаживается

**Недостатки**:
- Накопление ошибок округления
- Использование вещественной арифметики
- Неэффективность при больших отрезках

**Сложность**: O(n), где n = max(|Δx|, |Δy|)

### 2. Алгоритм ЦДА (Digital Differential Analyzer)

**Принцип работы**: Улучшенная версия пошагового алгоритма. Использует дифференциальный анализ для вычисления приращений координат.

**Математические формулы**:
- `steps = max(|Δx|, |Δy|)`
- `x_(i+1) = x_i + Δx/steps`
- `y_(i+1) = y_i + Δy/steps`

**Реализация**:
```javascript
function dda(x1, y1, x2, y2) {
    const dx = x2 - x1, dy = y2 - y1;
    const steps = Math.max(Math.abs(dx), Math.abs(dy));
    const xinc = dx / steps, yinc = dy / steps;
    let x = x1, y = y1;
    for (let i = 0; i <= steps; i++) {
        plot(Math.round(x), Math.round(y));
        x += xinc; y += yinc;
    }
}
```

**Преимущества**:
- Проще чем Брезенхем
- Хорошо работает для неглубоких линий

**Недостатки**:
- Округление на каждом шаге
- Вещественная арифметика
- Медленнее целочисленных алгоритмов

**Область применения**: Образовательные цели, простые графические системы

### 3. Алгоритм Брезенхема (отрезок)

**Принцип работы**: Целочисленный алгоритм, использующий только сложение и вычитание. Основан на анализе ошибки для выбора следующего пикселя.

**Основные шаги**:
1. Вычисление Δx, Δy
2. Инициализация ошибки: `err = Δx - Δy`
3. На каждом шаге: `e2 = 2 × err`
4. Если `e2 > -Δy`: `err -= Δy`, `x += sx`
5. Если `e2 < Δx`: `err += Δx`, `y += sy`

**Реализация**:
```javascript
function bresenhamLine(x1, y1, x2, y2) {
    let dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1);
    let sx = x1 < x2 ? 1 : -1, sy = y1 < y2 ? 1 : -1;
    let err = dx - dy;
    while (true) {
        plot(x1, y1);
        if (x1 === x2 && y1 === y2) break;
        let e2 = 2 * err;
        if (e2 > -dy) { err -= dy; x1 += sx; }
        if (e2 < dx) { err += dx; y1 += sy; }
    }
}
```

**Преимущества**:
- Только целочисленная арифметика
- Высокая скорость выполнения
- Точность без ошибок округления
- Широкое применение в компьютерной графике

**Недостатки**:
- Более сложная реализация
- Ступенчатость линий (алиасинг)

**Сложность**: O(n), оптимизированная версия

### 4. Алгоритм Брезенхема (окружность)

**Принцип работы**: Использует 8-точечную симметрию окружности для построения только 1/8 части, остальные точки вычисляются симметрично.

**Ключевые особенности**:
- Начальная ошибка: `d = 3 - 2r`
- Целочисленная арифметика без умножения
- 8-точечная симметрия для эффективности
- Построение от 0° до 45°, затем отражение

**Формулы обновления ошибки**:
- Если `d > 0`: `y--`, `d += 4(x - y) + 10`
- Иначе: `d += 4x + 6`
- `x++` на каждой итерации

**Реализация**:
```javascript
function bresenhamCircle(x0, y0, r) {
    let x = 0, y = r, d = 3 - 2 * r;
    while (y >= x) {
        // Рисуем 8 симметричных точек
        plot(x0 + x, y0 + y); plot(x0 - x, y0 + y);
        plot(x0 + x, y0 - y); plot(x0 - x, y0 - y);
        plot(x0 + y, y0 + x); plot(x0 - y, y0 + x);
        plot(x0 + y, y0 - x); plot(x0 - y, y0 - x);
        x++;
        if (d > 0) { y--; d = d + 4 * (x - y) + 10; }
        else d = d + 4 * x + 6;
    }
}
```

**8 симметричных точек**:
- `(x, y), (-x, y), (x, -y), (-x, -y)`
- `(y, x), (-y, x), (y, -x), (-y, -x)`

**Преимущества**:
- Целочисленные вычисления
- Высокая эффективность
- Использование симметрии
- Точность построения

**Сложность**: O(r) вместо O(r²)

### 5. Алгоритм Ву (Xiaolin Wu's algorithm)

**Принцип работы**: Алгоритм с антиалиасингом, который рисует два пикселя с разной интенсивностью для сглаживания ступенек.

**Основные концепции**:
- Интенсивность пикселя зависит от расстояния до идеальной линии
- Каждый шаг рисует 2 пикселя с прозрачностью
- Используется вещественная арифметика для точности
- Альфа-канал для плавных переходов

**Ключевые шаги**:
1. Определение крутизны линии
2. Вычисление градиента (наклона)
3. Для каждого x: вычисление двух y-координат
4. Отрисовка двух пикселей с альфа-каналом

**Реализация с OpenCV**:
```javascript
function wuLineOpenCV(x1, y1, x2, y2) {
    const steep = Math.abs(y2 - y1) > Math.abs(x2 - x1);
    if (steep) { [x1, y1] = [y1, x1]; [x2, y2] = [y2, x2]; }
    if (x1 > x2) { [x1, x2] = [x2, x1]; [y1, y2] = [y2, y1]; }

    const dx = x2 - x1, dy = y2 - y1;
    const gradient = dx === 0 ? 1 : dy / dx;

    let y = y1;
    for (let x = x1; x <= x2; x++) {
        const yFloor = Math.floor(y);
        const alpha = y - yFloor;
        
        const color1 = new cv.Scalar(139, 69, 19, Math.round(255 * (1 - alpha)));
        const color2 = new cv.Scalar(139, 69, 19, Math.round(255 * alpha));
        
        if (steep) {
            drawSquareOpenCV(mat, yFloor, x, color1);
            drawSquareOpenCV(mat, yFloor + 1, x, color2);
        } else {
            drawSquareOpenCV(mat, x, yFloor, color1);
            drawSquareOpenCV(mat, x, yFloor + 1, color2);
        }
        y += gradient;
    }
}
```

**Формула прозрачности**: `alpha = дробная_часть(y)`

**Преимущества**:
- Визуальное сглаживание линий
- Устранение ступенчатости
- Профессиональное качество графики

**Недостатки**:
- Вычислительная сложность
- Использование прозрачности
- Медленнее простых алгоритмов

**Область применения**: Качественная графика, полиграфия, САПР

## Интеграция OpenCV.js

### Особенности реализации:

- **Автоматическая инициализация** через `cv.onRuntimeInitialized`
- **Резервный режим** - fallback на Canvas API при недоступности OpenCV
- **Эффективная отрисовка** через `cv.rectangle()` и `cv.circle()`
- **Работа с матрицами** - использование `cv.Mat` для операций с изображениями
- **Управление памятью** - корректное освобождение ресурсов через `mat.delete()`

### Пример использования OpenCV:
```javascript
const mat = new cv.Mat(canvas.height, canvas.width, cv.CV_8UC4);
mat.setTo(new cv.Scalar(255, 255, 255, 255));
const point = gridToCanvas(x, y);
const topLeft = new cv.Point(point.cx - halfSize, point.cy - halfSize);
const bottomRight = new cv.Point(point.cx + halfSize, point.cy + halfSize);
cv.rectangle(mat, topLeft, bottomRight, color, -1);
cv.imshow('canvas', mat);
mat.delete();
```

## Архитектура приложения

### Модули:

1. **Система координат** - преобразование сеточных координат в пиксели
2. **Отрисовка сетки** - построение осей и разметки через OpenCV
3. **Алгоритмы растеризации** - 5 реализованных методов с OpenCV интеграцией
4. **Измерение производительности** - точные замеры времени выполнения
5. **Пользовательский интерфейс** - управление и отображение результатов

### Поток данных:
```
Пользовательский ввод → Выбор алгоритма → OpenCV инициализация → 
Выполнение вычислений → Визуализация через cv.imshow() → Анализ производительности
```

## Пример работы

### Настройка:
- Выбор алгоритма из списка
- Ввод координат: X₁=-10, Y₁=-5, X₂=10, Y₂=8
- Автоматическое использование OpenCV при доступности

### Выполнение:
- Алгоритм выполняется 5 раз для усреднения
- Отображается время выполнения с указанием режима (OpenCV/Canvas)
- Визуализация на координатной сетке

### Сравнение:
- Тестирование разных алгоритмов на одинаковых координатах
- Сравнение времени выполнения и качества визуализации
- Анализ компромиссов между скоростью и качеством

## Преимущества реализации

- **Полностью клиентское решение** с интеграцией OpenCV.js
- **Интуитивный интерфейс** с адаптивным дизайном
- **Точные измерения производительности** для OpenCV и Canvas
- **Наглядная визуализация** процессов растеризации
- **Образовательная направленность** с подробными описаниями алгоритмов
- **Кроссплатформенная совместимость** и работа в современных браузерах
- **Аппаратное ускорение** через WebAssembly-сборку OpenCV

## Вывод

Приложение эффективно демонстрирует работу ключевых алгоритмов компьютерной графики с интеграцией OpenCV.js, позволяя на практике изучить их особенности, производительность и области применения в современных веб-технологиях. Реализация показывает возможности использования компьютерного зрения непосредственно в браузере для образовательных и практических задач, обеспечивая глубокое понимание фундаментальных алгоритмов растеризации и их практической реализации.
