# Визуализация растровых алгоритмов с использованием OpenCV.js

## Описание

Интерактивное веб-приложение для изучения и сравнения классических алгоритмов компьютерной графики с интеграцией OpenCV.js. Позволяет визуализировать процесс построения графических примитивов на растровой сетке с возможностью измерения производительности и демонстрации использования компьютерного зрения в браузере.

## Возможности

### Поддерживаемые алгоритмы:

- **Пошаговый алгоритм** - базовый метод построения по оси X с независимым вычислением координат
- **Алгоритм ЦДА (DDA)** - цифровой дифференциальный анализатор с накоплением координат
- **Алгоритм Брезенхема (линия)** - целочисленный алгоритм без операций с плавающей точкой
- **Алгоритм Брезенхема (окружность)** - эффективное построение с использованием 8-сторонней симметрии
- **Алгоритм Ву** - сглаживание линий с антиалиасингом через OpenCV

### Система визуализации:

- Координатная сетка 800×800 пикселей
- Центр координат в середине холста
- Подписи осей с шагом 1 единица
- Дискретное отображение пикселей в виде квадратов
- Интеграция OpenCV.js для аппаратно-ускоренной отрисовки

## Технологии

- **Frontend**: HTML5, CSS3, JavaScript ES6+
- **Компьютерное зрение**: OpenCV.js 4.8.0
- **Графика**: Canvas API + OpenCV Mat операции
- **Производительность**: Performance API для точных замеров
- **Интерфейс**: Адаптивная верстка с CSS Grid/Flexbox

## Реализованные алгоритмы

### 1. Пошаговый алгоритм

**Принцип работы**: Простой алгоритм, который проходит по оси X и вычисляет Y для каждого X с помощью уравнения прямой.

**Математические формулы:**
- `y = y₁ + (y₂ - y₁) × (x - x₁) / (x₂ - x₁)`
- Для каждого x от x₁ до x₂ вычисляется y
- Округление: `Math.round(y)`

**Реализация:**
```javascript
function stepByStep(x1, y1, x2, y2) {
    const startX = Math.min(x1, x2);
    const endX = Math.max(x1, x2);
    
    for (let x = startX; x <= endX; x++) {
        const y = y1 + (y2 - y1) * (x - x1) / (x2 - x1);
        plot(x, Math.round(y));
    }
}
```

**Преимущества:**
- Простота реализации и понимания
- Легко отлаживается

**Недостатки:**
- Может пропускать пиксели на крутых линиях
- Использование вещественной арифметики

**Сложность**: O(n), где n = |Δx|

### 2. Алгоритм ЦДА (Digital Differential Analyzer)

**Принцип работы**: Использует дифференциальные приращения для накопления координат. Выбирает большее из |Δx|, |Δy| как количество шагов.

**Математические формулы:**
- `steps = max(|Δx|, |Δy|)`
- `x_inc = Δx / steps`
- `y_inc = Δy / steps`
- Округление: `Math.floor(x)`, `Math.floor(y)`

**Реализация:**
```javascript
function dda(x1, y1, x2, y2) {
    const dx = x2 - x1, dy = y2 - y1;
    const steps = Math.max(Math.abs(dx), Math.abs(dy));
    const xIncrement = dx / steps, yIncrement = dy / steps;
    
    let x = x1, y = y1;
    for (let i = 0; i <= steps; i++) {
        plot(Math.floor(x), Math.floor(y), "#006400");
        x += xIncrement;
        y += yIncrement;
    }
}
```

**Преимущества:**
- Равномерное покрытие пикселей
- Хорошо работает для всех типов линий

**Недостатки:**
- Накопление ошибок округления
- Вещественная арифметика

**Область применения**: Образовательные цели, простые графические системы

### 3. Алгоритм Брезенхема (отрезок)

**Принцип работы**: Целочисленный алгоритм, использующий только сложение и вычитание. Основан на анализе ошибки для выбора следующего пикселя.

**Основные шаги:**
1. Вычисление Δx = |x₂ - x₁|, Δy = |y₂ - y₁|
2. Определение направлений: sx = sign(x₂ - x₁), sy = sign(y₂ - y₁)
3. Инициализация ошибки: err = Δx - Δy
4. На каждом шаге: e₂ = 2 × err
5. Если e₂ > -Δy: err -= Δy, x += sx
6. Если e₂ < Δx: err += Δx, y += sy

**Реализация:**
```javascript
function bresenhamLine(x1, y1, x2, y2) {
    let dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1);
    let sx = x1 < x2 ? 1 : -1, sy = y1 < y2 ? 1 : -1;
    let err = dx - dy;
    
    while (true) {
        plot(x1, y1, "#00008B");
        if (x1 === x2 && y1 === y2) break;
        
        let e2 = 2 * err;
        if (e2 > -dy) { err -= dy; x1 += sx; }
        if (e2 < dx) { err += dx; y1 += sy; }
    }
}
```

**Преимущества:**
- Только целочисленная арифметика
- Высокая скорость выполнения
- Точность без ошибок округления

**Недостатки:**
- Более сложная реализация
- Ступенчатость линий (алиасинг)

**Сложность**: O(n), оптимизированная версия

### 4. Алгоритм Брезенхема (окружность)

**Принцип работы**: Использует 8-точечную симметрию окружности для построения только 1/8 части, остальные точки вычисляются симметрично.

**Ключевые особенности:**
- Начальная ошибка: d = 3 - 2r
- Целочисленная арифметика без умножения
- 8-точечная симметрия для эффективности
- Построение от 0° до 45°, затем отражение

**Формулы обновления ошибки:**
- Если d > 0: y--, d += 4(x - y) + 10
- Иначе: d += 4x + 6
- x++ на каждой итерации

**Реализация:**
```javascript
function bresenhamCircle(x0, y0, r) {
    let x = 0, y = r, d = 3 - 2 * r;
    
    while (x <= y) {
        plot(x0 + x, y0 + y, "#8B4513");
        plot(x0 - x, y0 + y, "#8B4513");
        plot(x0 + x, y0 - y, "#8B4513");
        plot(x0 - x, y0 - y, "#8B4513");
        plot(x0 + y, y0 + x, "#8B4513");
        plot(x0 - y, y0 + x, "#8B4513");
        plot(x0 + y, y0 - x, "#8B4513");
        plot(x0 - y, y0 - x, "#8B4513");
        
        x++;
        if (d > 0) {
            y--;
            d = d + 4 * (x - y) + 10;
        } else {
            d = d + 4 * x + 6;
        }
    }
}
```

**8 симметричных точек:**
- (x, y), (-x, y), (x, -y), (-x, -y)
- (y, x), (-y, x), (y, -x), (-y, -x)

**Преимущества:**
- Целочисленные вычисления
- Высокая эффективность
- Использование симметрии
- Точность построения

**Сложность**: O(r) вместо O(r²)

### 5. Алгоритм Ву (Xiaolin Wu's algorithm)

**Принцип работы**: Алгоритм с антиалиасингом, который рисует два пикселя с разной интенсивностью для сглаживания ступенек.

**Основные концепции:**
- Интенсивность пикселя зависит от расстояния до идеальной линии
- Каждый шаг рисует 2 пикселя с прозрачностью
- Используется вещественная арифметика для точности
- Альфа-канал для плавных переходов

**Ключевые шаги:**
1. Определение крутизны линии
2. Вычисление градиента (наклона)
3. Для каждого x: вычисление двух y-координат
4. Отрисовка двух пикселей с альфа-каналом

**Формула прозрачности**: `alpha = дробная_часть(y)`

**Преимущества:**
- Визуальное сглаживание линий
- Устранение ступенчатости
- Профессиональное качество графики

**Недостатки:**
- Вычислительная сложность
- Использование прозрачности
- Медленнее простых алгоритмов

**Область применения**: Качественная графика, полиграфия, САПР

## Интеграция OpenCV.js

### Особенности реализации:

- Автоматическая инициализация через `cv.onRuntimeInitialized`
- Резервный режим - fallback на Canvas API при недоступности OpenCV
- Эффективная отрисовка через `cv.rectangle()` и операции с матрицами
- Работа с матрицами - использование `cv.Mat` для операций с изображениями
- Управление памятью - корректное освобождение ресурсов через `mat.delete()`

### Пример использования OpenCV:

```javascript
function drawSquareOpenCV(mat, x, y, color) {
    const point = gridToCanvas(x, y);
    const halfSize = Math.floor(size / 2);
    const topLeft = new cv.Point(point.cx - halfSize + 1, point.cy - halfSize + 1);
    const bottomRight = new cv.Point(point.cx + halfSize - 1, point.cy + halfSize - 1);
    
    cv.rectangle(mat, topLeft, bottomRight, color, -1);
}
```

## Архитектура приложения

### Модули:

- **Система координат** - преобразование сеточных координат в пиксели
- **Отрисовка сетки** - построение осей и разметки через OpenCV
- **Алгоритмы растеризации** - 5 реализованных методов с OpenCV интеграцией
- **Измерение производительности** - точные замеры времени выполнения
- **Пользовательский интерфейс** - управление и отображение результатов

### Поток данных:

```
Пользовательский ввод → Выбор алгоритма → OpenCV инициализация → 
Выполнение вычислений → Визуализация через cv.imshow() → Анализ производительности
```

## Пример работы

### Настройка:
- Выбор алгоритма из списка
- Ввод координат: X₁=-10, Y₁=-5, X₂=10, Y₂=8
- Автоматическое использование OpenCV при доступности

### Выполнение:
- Алгоритм выполняется 5 раз для усреднения
- Отображается время выполнения с указанием режима (OpenCV/Canvas)
- Визуализация на координатной сетке

### Сравнение:
- Тестирование разных алгоритмов на одинаковых координатах
- Сравнение времени выполнения и качества визуализации
- Анализ компромиссов между скоростью и качеством

## Преимущества реализации

- Полностью клиентское решение с интеграцией OpenCV.js
- Интуитивный интерфейс с адаптивным дизайном
- Точные измерения производительности для OpenCV и Canvas
- Наглядная визуализация процессов растеризации
- Образовательная направленность с подробными описаниями алгоритмов
- Кроссплатформенная совместимость и работа в современных браузерах
- Аппаратное ускорение через WebAssembly-сборку OpenCV

## Вывод

Приложение эффективно демонстрирует работу ключевых алгоритмов компьютерной графики с интеграцией OpenCV.js, позволяя на практике изучить их особенности, производительность и области применения в современных веб-технологиях. Реализация показывает возможности использования компьютерного зрения непосредственно в браузере для образовательных и практических задач, обеспечивая глубокое понимание фундаментальных алгоритмов растеризации и их практической реализации.
